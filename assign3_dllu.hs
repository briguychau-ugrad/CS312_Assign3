-- ["--B---","--B---","XXB---","--AA--","------","------"]
{-

Brian Chau 30006118 b8z7
Daniel Lu 75592063 a7e7

Assignment 3 CPSC 312

-}

rush_hour :: [String] -> [[String]]
rush_hour s
	| valid s = reverse (search [s] [])
	| otherwise = error "lolwut"

-- checks if the grid is 6x6
-- all characters other than '-' and 'A' to 'Z' are ignored and treated as obstacles
valid :: [String] -> Bool
valid s = (length s) == 6 && sum([bool2int ((length (s!!i))==6) | i <- [0..5]]) == 6

-- checks if state is a goal state
isgoal :: [String] -> Bool
isgoal state = (state!!2!!5)=='X'

-- performs state search
search :: [[String]] -> [[String]] -> [[String]]
search unexplored path
	| null unexplored		= []
	| isgoal (head unexplored)	= (head unexplored):path
	| (not (null newstates))	= newstates
	| otherwise			= search (tail unexplored) path
	where newstates = search (generatemoves (head unexplored) path) ((head unexplored):path)

-- generates all moves for this state
-- sorted in descending order of heuristic value
-- vertical moves are generated by using the horizontal move generator on a transposed state
generatemoves :: [String] -> [[String]] -> [[String]]
generatemoves s visited = heuristicsort (clean (concat [movegenrow s i | i <- [0..5]] ++ [transpose moves | moves <- concat [(movegenrow (transpose s) i) | i <-[0..5]]]))
	where transpose u = [[u!!j!!i | j <- [0..5]] | i <- [0..5]]
	      clean u = [k | k <- u, k/=s, not (elem k visited)]

-- generates all possible horizontal moves for this row
movegenrow :: [String] -> Int -> [[String]]
movegenrow s i = moverow moveright ++ moverow moveleft
	where moverow whatmove = [(take i s) ++ [whatmove (s!!i) car] ++ (drop (i+1) s) | car <- getcars (s!!i)]

-- gets all car colours on this row
-- cars must be of length greater than one
-- cars must be a capital letter
-- assumes that all cars are contiguous and there are no two cars of the same colour
getcars :: String -> String
getcars s = [a | a <- ['A'..'Z'], length (filter (==a) s) > 1]

-- moves car of colour c one step to the right
moveright :: String -> Char -> String
moveright s c = replacestr s (car++"-") ('-':car) where car = (filter (==c) s)

-- moves car of colour c one step to the left
moveleft :: String -> Char -> String
moveleft s c = replacestr s ('-':car) (car++"-") where car = (filter (==c) s)

-- replaces the first occurrence of substring
replacestr :: String -> String -> String -> String
replacestr [] _ _ = ""
replacestr (x:xs) from to
	| length (x:xs) < n          = (x:xs)
	| take n (x:xs) == from      = to ++ drop n (x:xs)
	| otherwise                  = x:(replacestr xs from to)
	where n = length from

-- sorts a set of states by heuristic value from high to low
-- based on quicksort function from the first (or was it second?) lecture
heuristicsort :: [[String]] -> [[String]]
heuristicsort [] = []
heuristicsort (x:xs) = (heuristicsort (filter (heuristiccompare x) xs)) ++ [x] ++ (heuristicsort (filter (heuristiccompare2 x) xs))
	where heuristiccompare a b = (heuristic a) < (heuristic b)
	      heuristiccompare2 a b = (heuristic a) >= (heuristic b)

-- counts the number of cars on the edges of the grid
-- cars in the corners are counted twice
-- the idea is that when most cars are on the edges, you have more room to move
heuristic :: [String] -> Int
heuristic s = sum [(eval (s!!j!!0)) + (eval (s!!0!!j)) + (eval (s!!j!!5)) + (eval (s!!0!!5)) | j <-[0..5]]
	where eval a = bool2int (a/='-')

-- as a c++ programmer I sometimes add bools as if they were ints lol
bool2int :: Bool -> Int
bool2int True = 1
bool2int False = 0
