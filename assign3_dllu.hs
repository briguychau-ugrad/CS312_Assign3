-- ["--B---","--B---","XXB---","--AA--","------","------"]
-- ["AA---B","C--D-B","CXXD-B","C--D--","E---FF","E-GGG-"]
-- ["-----A","-----A","-XX--A","-CCCCC","-DDDDD","-EEEEE"]
{-

Brian Chau 30006118 b8z7
Daniel Lu 75592063 a7e7

Assignment 3 CPSC 312

-}
-- print the state for pretty debugging
printstate :: [String] -> IO()
printstate s = do
    putStrLn (s!!0)
    putStrLn (s!!1)
    putStrLn (s!!2)
    putStrLn (s!!3)
    putStrLn (s!!4)
    putStrLn (s!!5)

rush_hour :: [String] -> [[String]]
rush_hour s
    | valid s = reverse (search [[s]] [])
    | otherwise = error "Invalid starting position."

-- checks if the grid is 6x6
-- all characters other than '-' and 'A' to 'Z' are ignored and treated as obstacles
-- checks that row 2 (0-indexed) has a car of colour 'X' of length 2
valid :: [String] -> Bool
valid s = (length s) == 6 && sum([bool2int ((length (s!!i))==6) | i <- [0..5]]) == 6 && length (filter (=='X') (s!!2)) == 2

-- checks if state is a goal state
isgoal :: [String] -> Bool
isgoal state = (state!!2!!5)=='X'

-- performs state search using breadth first search
-- may be computationally slower, but produces optimal solutions
search :: [[[String]]] -> [[String]] -> [[String]]
search frontier visited
    | null frontier = []
    | isgoal (head (head frontier)) = head frontier
    | otherwise = search ((tail frontier)++[k:(head frontier) | k <- newstates]) (visited++newstates)
    where newstates = generatemoves (head (head frontier)) visited

-- performs state search using depth first search
--search :: [[String]] -> [[String]] -> [[String]]
--search frontier visited
--    | null frontier             = []
--    | isgoal (head frontier)    = (head frontier):visited
--    | (not (null newstates))    = newstates
--    | otherwise                 = search (tail frontier) visited
--    where newstates = search (generatemoves (head frontier) visited) ((head frontier):visited)

-- generates all moves for this state
-- sorted in descending order of heuristic value
-- vertical moves are generated by using the horizontal move generator on a transposed state
generatemoves :: [String] -> [[String]] -> [[String]]
generatemoves s visited = heuristicsort (clean (concat [movegenrow s i | i <- [0..5]] ++ [reverse (transpose moves) | moves <- concat [(movegenrow (transpose (reverse s)) i) | i <-[0..5]]]))
    where transpose u = [[u!!j!!i | j <- [0..5]] | i <- [0..5]]
          clean u = [k | k <- u, k/=s, not (elem k visited)]

-- generates all possible horizontal moves for this row
movegenrow :: [String] -> Int -> [[String]]
movegenrow s i = moverow moveright ++ moverow moveleft
    where moverow whatmove = [(take i s) ++ [whatmove (s!!i) car] ++ (drop (i+1) s) | car <- getcars (s!!i)]

-- gets all car colours on this row
-- cars must be of length greater than one
-- cars must be a capital letter
-- assumes that all cars are contiguous and there are no two cars of the same colour
getcars :: String -> String
getcars s = [a | a <- ['A'..'Z'], length (filter (==a) s) > 1]

-- moves car of colour c as far as possible to the right
moveright :: String -> Char -> String
moveright s c = r (r (r (r s)))
    where r v = replacestr v (car++"-") ('-':car) where car = (filter (==c) s)

-- moves car of colour c as far as possible to the left
moveleft :: String -> Char -> String
moveleft s c = r (r (r (r s)))
    where r v = replacestr v ('-':car) (car++"-") where car = (filter (==c) s)

-- replaces the first occurrence of substring
replacestr :: String -> String -> String -> String
replacestr [] _ _ = ""
replacestr (x:xs) from to
    | length (x:xs) < n          = (x:xs)
    | take n (x:xs) == from      = to ++ drop n (x:xs)
    | otherwise                  = x:(replacestr xs from to)
    where n = length from

-- sorts a set of states by heuristic value from high to low
-- based on quicksort function from the first (or was it second?) lecture
heuristicsort :: [[String]] -> [[String]]
heuristicsort [] = []
heuristicsort (x:xs) = (heuristicsort (filter (heuristiccompare x) xs)) ++ [x] ++ (heuristicsort (filter (heuristiccompare2 x) xs))
    where heuristiccompare a b = (heuristic a) < (heuristic b)
          heuristiccompare2 a b = (heuristic a) >= (heuristic b)

-- computes heuristic value of a state. The higher the value, the more desirable.
heuristic :: [String] -> Int
heuristic s = heuristic1 s + heuristic2 s

-- counts the distance the 'X' car is from the goal
-- plus the number of empty spaces from the 'X' car to the goal
heuristic1 :: [String] -> Int
heuristic1 [_,_,'X':'X':xs,_,_,_] = 0 + length (filter (=='-') xs)
heuristic1 [_,_,_:'X':'X':xs,_,_,_] = 1 + length (filter (=='-') xs)
heuristic1 [_,_,_:_:'X':'X':xs,_,_,_] = 2 + length (filter (=='-') xs)
heuristic1 [_,_,_:_:_:'X':'X':xs,_,_,_] = 3 + length (filter (=='-') xs)
heuristic1 [_,_,_:_:_:_:'X':'X':xs,_,_,_] = 4 + length (filter (=='-') xs)

-- counts the number of cars on the edges of the grid
-- cars in the corners are counted twice
-- the idea is that when most cars are on the edges, you have more room to move
heuristic2 :: [String] -> Int
heuristic2 s = sum [(eval (s!!j!!0)) + (eval (s!!0!!j)) + (eval (s!!j!!5)) + (eval (s!!5!!j)) | j <-[0..5]]
        where eval a = bool2int (a/='-')

-- as a c++ programmer I sometimes add bools as if they were ints lol
bool2int :: Bool -> Int
bool2int True = 1
bool2int False = 0
